const fs = require('fs-extra')
const path = require('path')
const postcss = require('postcss')
const env = require('postcss-preset-env')
const CleanCss = require('clean-css')
const nesting = require('postcss-nesting')
const perfectionist = require('perfectionist')
const parseValue = require('postcss-value-parser')
const processNot = require('postcss-selector-not')
const removeComments = require('postcss-discard-comments')

const ConsoleUtils = require('./utilities/ConsoleUtils.js')
const ErrorUtils = require('./utilities/ErrorUtils.js')
const Config = require('./Config.js')
const Mixin = require('./Mixin.js')
const Func = require('./Func.js')

module.exports = class StyleSheet extends NGN.EventEmitter {
  #initialized = false
  #typographyEngineEnabled = false
  #mixins = {}
  #functions = {}

  constructor (filepath) {
    super()

    this.path = filepath
    this.raw = fs.readFileSync(filepath).toString()
    this.ast = postcss.parse(this.raw, { from: filepath })
  }

  #processFunctions = cb => {
    this.ast.walkDecls(decl => {
      let parsed = parseValue(decl.value)

      if (!parsed.nodes.some(node => node.type === 'function')) {
        return
      }

      let resolved = true

      parsed.walk((node, index) => {
        if (node.type !== 'function') {
          return
        }

        let func = new Func(node, decl.source.start)

        func.resolve((err, value) => {
          if (err) {
            throw err
          }

          node.value = value
          node.type = 'word'
          node.nodes = []
        })
      })


      decl.value = parsed.toString()
    })

    cb()
  }

  process (cb) {
    let queue = new NGN.Tasks()
    let minified

    queue.on('complete', () => cb(null, {
      css: minified ? minified.styles : this.ast.toString(),
      sourceMap: minified ? NGN.coalesce(minified.sourceMap) : null
    }))

    queue.add('Processing Mixins', this.#processAtRules)

    queue.add('Processing :not() Instances', this.#processNotSelectors)

    queue.add('Processing Functions', this.#processFunctions)

    queue.add('Processing Nesting', this.#processNesting)

    // this.#namespaceSelectors()

    queue.add('Initializing Chassis Built-ins', next => {
      if (!this.#initialized) {
        return next()
      }

      // Prepend Block Component Reset
      // Prepend Inline-block Component Reset
      // Prepend Inline Component Reset

      // if (this.#typographyEngineEnabled) {
      //   // Prepend Typography Ranges
      //   this.#initTypographyEngine()
      // }

      // Prepend p rules
      // Prepend Inner Containers
      // Prepend Outer Containers
      // Prepend Root Headings
      // Prepend body rule
      // Prepend html rule

      // Prepend constraints

      // Prepend global modifiers

      // Prepend @custom-media rules

      // Prepend custom properties (:root)

      // Prepend reset

      // Prepend @viewport rules

      next()
    })

    // Hoist imports

    // this.#postProcess()

    queue.add('Processing CSS4 Syntax', this.#processCSS4)

    if (Config.minify) {
      queue.add('Minifying Output', next => {
        minified = new CleanCss({
          sourceMap: Config.sourceMap
        }).minify(this.ast.toString())

        next()
      })

    } else {
      queue.add('Beautifying Output', this.#beautify)
    }

    queue.run(true)
  }

  #beautify = cb => {
    // TODO: Add try/catch statements here
    this.ast = perfectionist.process(removeComments.process(this.ast).root).root

    // Remove empty rulesets
    this.ast.walkRules(rule => {
      if (rule.nodes.length === 0) {
        rule.remove()
        return
      }
    })

    cb()
  }

  #initTypographyEngine = () => console.log('Init Typography')

  #processAtRules = cb => {
    let registered = this.#registerMixins()

    if (!registered) {
      return cb()
    }

    this.#processMixins('import')
    this.#processMixins('theme')
    this.#processMixins('all')

    // Recurse to handle imported mixins
    this.#processAtRules(cb)
  }

  #processCSS4 = cb => env.process(this.ast, { from: this.path }, Config.env)
    .then(processed => {
      this.ast = processed
      cb()
    }).catch(err => {
      throw ErrorUtils.createError({ message: err })
    })

  #processMixin = mixin => mixin.resolve()

  #processMixins = type => {
    if (!type) {
      return
    }

    if (type === 'all') {
      for (let type in this.#mixins) {
        this.#processMixins(type)
      }

      return
    }

    if (!this.#mixins.hasOwnProperty(type)) {
      return
    }

    this.#mixins[type].forEach(this.#processMixin)
    delete this.#mixins[type]
  }

  #processNesting = () => this.ast = nesting.process(this.ast).root

  #processNotSelectors = cb => {
    this.ast = processNot.process(this.ast).root
    cb()
  }

  #registerMixins = () => {
    let registered = false

    this.ast.walkAtRules('chassis', atRule => {
      let mixin = new Mixin(atRule)

      if (mixin.name === 'init') {
        this.#initialized = true
        return atRule.remove()
      }

      registered = true

      if (this.#mixins.hasOwnProperty(mixin.name)) {
        return this.#mixins[mixin.name].push(mixin)
      }

      this.#mixins[mixin.name] = [mixin]
    })

    return registered
  }
}
